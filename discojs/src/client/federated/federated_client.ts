import createDebug from "debug";

import {
  serialization,
  type WeightsContainer,
} from "../../index.js";
import { Base as Client } from "../base.js";
import { type, type ClientConnected, type ClientDisconnected } from "../messages.js";
import {
  type EventConnection,
  waitMessageWithTimeout,
  // waitMessage,
  WebSocketServer,
} from "../event_connection.js";
import * as messages from "./messages.js";

const debug = createDebug("discojs:client:federated");

/**
 * Client class that communicates with a centralized, federated server, when training
 * a specific task in the federated setting.
 */
export class FederatedClient extends Client {
  /**
   * Arbitrary node id assigned to the federated server which we are communicating with.
   * Indeed, the server acts as a node within the network. In the federated setting described
   * by this client class, the server is the only node which we are communicating with.
   */
  public static readonly SERVER_NODE_ID = "federated-server-node-id";
  
  // Total number of other federated contributors, including this client, excluding the server
  // E.g., if 3 users are training a federated model, nbOfParticipants is 3
  #nbOfParticipants: number = 1;
  
  /**
   * Flag set by the server to tell clients to pause and wait until more
   * participants join the session
   */
  #waitingForMoreParticipants = false;
  /**
   * Along with the boolean flag, we also use a promise to wait
   * until the server signals that we can resume the training
   */
  #promiseForMoreParticipants: Promise<void> | undefined = undefined;

  // the number of participants excluding the server
  override get nbOfParticipants(): number {
    return this.#nbOfParticipants
  }

  /**
   * Opens a new WebSocket connection with the server and listens to new messages over the channel
   */
  private async connectServer(url: URL): Promise<EventConnection> {
    const server: EventConnection = await WebSocketServer.connect(
      url,
      messages.isMessageFederated, // can only receive federated message types from the server
      messages.isMessageFederated, // idem for messages that the client can send
    );
    return server;
  }

  /**
   * Initializes the connection to the server and get our own node id.
   * TODO: In the federated setting, should return the current server-side round
   * for the task.
   */
  async connect(): Promise<void> {
    const serverURL = new URL("", this.url.href);
    switch (this.url.protocol) {
      case "http:":
        serverURL.protocol = "ws:";
        break;
      case "https:":
        serverURL.protocol = "wss:";
        break;
      default:
        throw new Error(`unknown protocol: ${this.url.protocol}`);
    }

    serverURL.pathname += `federated/${this.task.id}`;

    this._server = await this.connectServer(serverURL);
    
    // Setup an event callback if the server signals that we should 
    // wait for more participants
    this.server.on(type.WaitingForMoreParticipants,
      () => {
        debug("Received WaitingForMoreParticipants")
        this.#promiseForMoreParticipants = this.waitForMoreParticipants()
      })

    this.aggregator.registerNode(FederatedClient.SERVER_NODE_ID);

    const msg: ClientConnected = {
      type: type.ClientConnected,
    };
    this.server.send(msg);

    const received = await waitMessageWithTimeout(
      this.server,
      type.AssignNodeID,
    );
    debug(`[${received.id}] assign id generated by the server`);
    this._ownId = received.id;
    // Upon connecting, the server answers with a boolean
    // which indicates whether there are enough participants or not
    if (received.waitForMoreParticipants) {
      // Create a promise that resolves when enough participants join
      // The client awaits this promise before sending its local weight update
      this.#promiseForMoreParticipants = this.waitForMoreParticipants()
    }
    debug("Upon connecting, wait for participant flag %o", this.#waitingForMoreParticipants)
  }

  /**
   * Method called when the server notifies the client that there aren't enough 
   * participants (anymore) to start/continue training
   * The method sets waitingForMoreParticipants to true and creates
   * a promise that will resolve once the server notifies the client that the
   * training can resume
   * @returns a promise which resolves when enough participants joined the session
   */
  private async waitForMoreParticipants(): Promise<void> {
    this.#waitingForMoreParticipants = true
    return new Promise<void>((resolve) => {
      // "once" is important because we can't resolve the same promise multiple times
      this.server.once(type.EnoughParticipants, () => {
        debug("Received EnoughParticipants message from server")
        this.#waitingForMoreParticipants = false
        resolve()
      })
    })
  }

  /**
   * Disconnection process when user quits the task.
   */
  override async disconnect(): Promise<void> {
    const msg: ClientDisconnected = {
      type: type.ClientDisconnected,
    };
    this.server.send(msg); // notify the server we are disconnecting but don't wait for an answer
    await this.server.disconnect();
    this._server = undefined;
    this._ownId = undefined;

    this.aggregator.setNodes(this.aggregator.nodes.delete(FederatedClient.SERVER_NODE_ID));

    return Promise.resolve();
  }

  override onRoundBeginCommunication(): Promise<void> {
    // Prepare the result promise for the incoming round
    this.aggregationResult = new Promise((resolve) => this.aggregator.once('aggregation', resolve))
    return Promise.resolve();
  }

  /**
   * 
   * @param weights Local weights sent to the server at the end of the local training round
   * @param _round The trainer's aggregation round, which can be different from 
   * the server's round if the participant joined late
   * @returns the new global weights sent by the server
   */
  override async onRoundEndCommunication(weights: WeightsContainer): Promise<WeightsContainer> {
    // NB: For now, we suppose a fully-federated setting.

    if (this.aggregationResult === undefined) {
      throw new Error("local aggregation result was not set");
    }

    // First we check if we are waiting for more participants before sending our weight update
    if (this.#waitingForMoreParticipants) {
      if (this.#promiseForMoreParticipants === undefined) throw new Error("Promise should not be undefined")
        
      // wait for the promise to resolve, which takes as long as it takes for new participants to join
      debug("Awaiting the promise for more participants")
      await this.#promiseForMoreParticipants 
      debug("Promise resolved")
    }

    // Send our local contribution to the server
    // and receive the most recent weights as an answer to our contribution
    const payload: WeightsContainer = this.aggregator.makePayloads(weights).first()
    const msg: messages.SendPayload = {
      type: type.SendPayload,
      payload: await serialization.weights.encode(payload),
      round: this.aggregator.round,
    };

    // Need to await the resulting global model right after sending our local contribution
    // to make sure we don't miss it
    this.server.send(msg);
    const serverResult = await this.receiveServerResult();

    if (
      serverResult !== undefined &&
      this.aggregator.add(FederatedClient.SERVER_NODE_ID, serverResult, this.aggregator.round)
    ) {
      // Regular case: the server sends us its aggregation result which will serve our
      // own aggregation result.
    } else {
      // Unexpected case: for some reason, the server result is stale.
      debug(`[${this.ownId}] server result for round ${this.aggregator.round} is undefined or stale`);
      // We proceed to the next round without its result.
      this.aggregator.nextRound();
    }
    return await this.aggregationResult
  }

  /**
   * Wait for the server to reply with the most recent aggregated weights
   * after having sent out local weight update to the federated server
   */
  private async receiveServerResult(): Promise<WeightsContainer | undefined> {
    // Try receiving the latest update multiple times in case we receive outdated updates
    const MAX_NB_OF_TRIES = 3
    for (let nbOfTries = 0; nbOfTries < MAX_NB_OF_TRIES; nbOfTries++) {
      try {
        const { payload, round: serverRound, nbOfParticipants } = await waitMessageWithTimeout(
          this.server,
          type.ReceiveServerPayload,
          undefined,
          "Timeout while waiting for the server's model update"
        );
        
        // Store the server result only if it is not stale
        if (this.aggregator.round <= serverRound) {
          this.#nbOfParticipants = nbOfParticipants // Save the current participants
          const serverResult = serialization.weights.decode(payload);
          // Updates the aggregator's round if it's behind the server's.
          if (this.aggregator.round < serverRound) {
            this.aggregator.setRound(serverRound);
          }
          return serverResult;
        }
      } catch (e) {
        debug(`Error during try ${nbOfTries} of receiving server result: %o`, e);
      }
    }
    console.error(`Failed to receive server result in ${MAX_NB_OF_TRIES} tries`)
    return undefined // don't return anything if we failed
  }
}
